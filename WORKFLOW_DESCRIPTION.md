# 시스템 워크플로우 설명

## 전체 사용자 여정 (User Journey)

### 1단계: 회원가입 및 로그인

사용자가 웹사이트에 접속하면 회원가입 페이지가 나타납니다. 사용자는 이메일과 비밀번호를 입력하고 회원가입 버튼을 클릭합니다. 

프론트엔드(React)는 백엔드 API로 회원가입 요청을 보냅니다. 백엔드는 입력된 정보를 검증하고, 비밀번호를 해시화한 후 PostgreSQL 데이터베이스에 사용자 정보를 저장합니다. 회원가입이 완료되면 자동으로 로그인되어 JWT 토큰을 받게 됩니다.

### 2단계: Smart Wallet 생성

로그인 후 사용자는 티켓을 구매하기 전에 Smart Wallet을 생성해야 합니다. 사용자가 "지갑 생성" 버튼을 클릭하면, 백엔드는 사용자 ID를 기반으로 고유한 salt 값을 생성합니다.

이 salt 값과 서비스 계정 주소를 사용해 SmartWalletFactory 컨트랙트에서 Smart Wallet 주소를 계산합니다. CREATE2 방식을 사용하기 때문에 배포 전에도 주소를 미리 알 수 있습니다. 

만약 해당 주소에 아직 컨트랙트가 배포되지 않았다면, SmartWalletFactory가 Proxy 패턴을 사용해 Smart Wallet을 배포합니다. 배포가 완료되면 백엔드는 이 주소를 데이터베이스에 저장하고 사용자에게 반환합니다.

### 3단계: 이벤트 생성 (주최자)

주최자 역할을 가진 사용자는 이벤트를 생성할 수 있습니다. 이벤트 이름, 설명, 가격, 티켓 수량, 판매 기간, 이벤트 날짜 등을 입력합니다.

백엔드는 이 정보를 JSON 형태로 만들어 IPFS(Pinata)에 업로드합니다. IPFS는 분산 저장소이므로 메타데이터가 영구적으로 저장되고, 해시 값이 반환됩니다.

이 IPFS 해시와 함께 이벤트 정보를 데이터베이스에 먼저 저장합니다. 그 다음 EventManager 스마트 컨트랙트의 `createEvent` 함수를 호출하여 블록체인에 이벤트를 등록합니다. 블록체인에서 이벤트 ID가 반환되면, 데이터베이스의 이벤트 레코드를 업데이트합니다.

이벤트는 생성 직후 "대기 중(pending)" 상태이며, 관리자의 승인이 필요합니다.

### 4단계: 이벤트 승인 (관리자)

관리자는 승인 대기 중인 이벤트 목록을 확인하고, 적절한 이벤트를 승인할 수 있습니다. 승인 버튼을 클릭하면 백엔드는 EventManager 컨트랙트의 `approveEvent` 함수를 호출합니다.

블록체인에서 이벤트의 승인 상태가 변경되고, 데이터베이스의 이벤트 상태도 "승인됨(approved)"으로 업데이트됩니다. 이제 이벤트가 판매 기간 내에 있으면 "판매 중(active)" 상태가 되어 일반 사용자들이 티켓을 구매할 수 있습니다.

### 5단계: 티켓 구매 (구매자)

사용자가 이벤트 목록에서 원하는 이벤트를 선택하고 "구매하기" 버튼을 클릭합니다. 백엔드는 먼저 여러 가지 검증을 수행합니다:

- 이벤트가 승인되었는지 확인
- 현재 시간이 판매 기간 내에 있는지 확인
- 티켓이 매진되지 않았는지 확인
- 사용자가 이미 같은 이벤트의 티켓을 구매하지 않았는지 확인 (중복 구매 방지)

검증이 통과되면, 티켓 메타데이터를 생성하고 IPFS에 업로드합니다. 티켓 메타데이터에는 이벤트 이름, 날짜, 가격 등의 정보가 포함됩니다.

이제 Account Abstraction을 사용한 트랜잭션이 시작됩니다. 백엔드의 AA Service는 EventManager의 `purchaseTicket` 함수를 호출하기 위한 데이터를 인코딩합니다. 

UserOperation을 생성하기 위해 EntryPoint에서 현재 nonce 값을 조회합니다. 가스비 정보도 블록체인에서 조회하여 UserOperation에 포함시킵니다.

UserOperation이 준비되면, 서비스 계정의 private key로 서명합니다. 서명은 EIP-191 표준을 따릅니다.

서명된 UserOperation을 EntryPoint에 전송합니다. EntryPoint는 먼저 Smart Wallet의 `validateUserOp` 함수를 호출하여 서명을 검증하고 nonce를 확인합니다. 검증이 통과하면 Smart Wallet의 `execute` 함수를 호출합니다.

Smart Wallet은 EventManager의 `purchaseTicket` 함수를 호출합니다. EventManager는 다시 한번 검증을 수행한 후, TicketNFT 컨트랙트의 `mintTicket` 함수를 호출하여 NFT 티켓을 발행합니다.

NFT가 발행되면, EventManager는 구매자가 지불한 금액을 주최자에게 전송합니다. 모든 과정이 완료되면 `TicketSold` 이벤트가 발생합니다.

백엔드는 트랜잭션 완료를 기다린 후, 트랜잭션 receipt의 로그를 분석하여 발행된 티켓의 tokenId를 추출합니다. 이 정보를 데이터베이스에 저장하고 사용자에게 구매 완료를 알립니다.

### 6단계: 재판매 등록

구매한 티켓을 재판매하고 싶은 사용자는 "내 티켓" 페이지에서 해당 티켓을 선택하고 "재판매 등록" 버튼을 클릭합니다. 재판매 가격을 입력합니다. 가격은 원래 구매 가격의 최대 200%까지 설정할 수 있습니다.

백엔드는 먼저 사용자가 해당 티켓의 소유자인지 확인합니다. 데이터베이스에서 티켓 정보를 조회하고, EventManager에서 원래 티켓 가격을 조회하여 가격 상한선을 검증합니다.

검증이 통과되면 TicketMarketplace 컨트랙트의 `listTicketForResale` 함수를 호출하여 블록체인에 재판매 정보를 등록합니다. 데이터베이스에도 재판매 정보를 저장합니다.

### 7단계: 재판매 구매

다른 사용자가 마켓플레이스 페이지에서 재판매 중인 티켓을 확인하고 "구매하기" 버튼을 클릭합니다.

백엔드는 재판매 정보를 조회하고, TicketMarketplace 컨트랙트의 `buyResaleTicket` 함수를 호출합니다. 이 함수는 다음 작업을 수행합니다:

1. TicketNFT의 `safeTransferFrom` 함수를 호출하여 NFT 소유권을 판매자에서 구매자로 이전합니다.
2. 구매자가 지불한 금액에서 플랫폼 수수료(5%)를 제외한 나머지를 판매자에게 전송합니다.
3. 수수료를 플랫폼 수수료 수령자에게 전송합니다.

모든 거래가 완료되면 데이터베이스의 재판매 상태를 "판매 완료(sold)"로 업데이트합니다.

### 8단계: 환불 요청

이벤트가 취소되거나 개인 사정으로 티켓을 사용할 수 없게 된 경우, 사용자는 환불을 요청할 수 있습니다. "내 티켓" 페이지에서 해당 티켓을 선택하고 "환불 요청" 버튼을 클릭합니다.

백엔드는 환불 요청 정보를 데이터베이스에 저장합니다. 환불 요청은 "대기 중(pending)" 상태로 저장되며, 관리자나 주최자의 승인을 기다립니다.

### 9단계: 환불 처리 (관리자/주최자)

관리자나 주최자는 환불 요청 목록을 확인하고 적절한 요청을 승인할 수 있습니다. 승인 버튼을 클릭하면 백엔드는 RefundManager 컨트랙트의 `processRefund` 함수를 호출합니다.

이 함수는 다음 작업을 수행합니다:
1. TicketNFT의 `burnTicket` 함수를 호출하여 NFT를 소각합니다.
2. 환불 금액을 구매자의 Smart Wallet로 전송합니다.

환불이 완료되면 데이터베이스의 환불 요청 상태를 "처리 완료(processed)"로 업데이트하고, 티켓 상태도 "환불됨(refunded)"으로 변경합니다.

---

## 주요 특징

### Account Abstraction의 장점

일반적인 블록체인 트랜잭션과 달리, 이 시스템은 ERC-4337 Account Abstraction을 사용합니다. 사용자는 복잡한 지갑 설정이나 가스비 관리 없이도 티켓을 구매할 수 있습니다. Smart Wallet이 사용자를 대신하여 트랜잭션을 실행하고, 서비스가 가스비를 부담할 수 있습니다.

### 이중 저장 구조

모든 중요한 정보는 두 곳에 저장됩니다:
- **블록체인**: 티켓 소유권, 이벤트 정보, 재판매 정보 등 (변조 불가능)
- **데이터베이스**: 빠른 조회를 위한 메타데이터, 사용자 정보 등

이렇게 하면 블록체인의 불변성과 데이터베이스의 빠른 조회 성능을 모두 활용할 수 있습니다.

### IPFS를 통한 메타데이터 저장

이벤트와 티켓의 상세 정보는 IPFS에 저장됩니다. 블록체인에는 IPFS 해시만 저장하므로 가스비를 절약하면서도 상세한 정보를 저장할 수 있습니다.

---

## 전체 플로우 요약

1. **회원가입** → 데이터베이스에 사용자 정보 저장
2. **Smart Wallet 생성** → 블록체인에 Smart Wallet 배포
3. **이벤트 생성** → IPFS에 메타데이터 업로드 → 블록체인에 이벤트 등록
4. **이벤트 승인** → 블록체인에서 승인 상태 변경
5. **티켓 구매** → Account Abstraction으로 NFT 발행 → 주최자에게 지불
6. **재판매 등록** → 블록체인에 재판매 정보 등록
7. **재판매 구매** → NFT 소유권 이전 → 판매자에게 지불
8. **환불 요청** → 데이터베이스에 요청 저장
9. **환불 처리** → NFT 소각 → 구매자에게 환불

이 모든 과정이 블록체인에 기록되어 투명하고 검증 가능합니다.

